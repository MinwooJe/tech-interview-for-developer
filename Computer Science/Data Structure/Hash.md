## 해시(Hash)

데이터를 효율적으로 관리하기 위해, 임의의 길이 데이터를 고정된 길이의 데이터로 매핑하는 것
해시 함수를 구현하여 데이터 값을 해시 값으로 매핑한다.

- Hash Table
   - key를 value에 매핑하여 데이터를 젖아하는 자료구조. 해시 함수를 통해 각 키를 해시 코드로 변환하고, 이 해시 코드를 배열 인덱스로 사용하므로 값을 빠르게 탐색 가능.
   - 추가적인 메모리를 사용해, 검색, 삽입, 삭제 작업을 가능하게 함 => 매우 빠른 데이터 접근 속도 제공.
   - 충돌발생가능
<br>

```
Lee → 해싱함수 → 5
Kim → 해싱함수 → 3
Park → 해싱함수 → 2
...
Chun → 해싱함수 → 5 // Lee와 해싱값 충돌
```

결국 데이터가 많아지면, 다른 데이터가 같은 해시 값으로 충돌나는 현상이 발생함 **'collision' 현상**

**_그래도 해시 테이블을 쓰는 이유는?_**

> 적은 자원으로 많은 데이터를 효율적으로 관리하기 위해
>
> 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해짐!

- 언제나 동일한 해시값 리턴, index를 알면 빠른 데이터 검색이 가능해짐
- 해시테이블의 시간복잡도 O(1) - (이진탐색트리는 O(logN))

<br>

##### 충돌 회피 기법

1. **체이닝** : 충돌 발생 시(해시 버킷에 데이터가 이미 존재할 때) 새로운 데이터를 추가하기 위해 각 해시 버킷을 연결 리스트나 다른 형태의 자료구조로 확장하여 사용
   (제한 없이 계속 연결 가능, but 메모리 문제)
   - 각 버킷이 포인터를 사용해 연결 리스트를 구현. 해시 함수로부터 동일한 해시 값을 받는 서로 다른 키들이 하나의 버킷에 링크드 리스트 형태로 연결되어 저장됨.

3. **Open Addressing** : 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용 (해당 키 값에 저장되어있으면 또 다른 주소에 저장)
   - **선형 조사(Linear Probing)** : 충돌 발생시 정해진 고정 폭으로 이동하며 비어있는 공간을 찾음.
   - **제곱 탐사(Quadratic Probing)** : 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함
   - **이중 해싱(Double Hashing)** : 두 번째 해시 함수를 사용해 비어있는 공간을 찾음.
     
   - **클러스터링** : 오픈 어드레싱 방법에서 주로 문제가 되는 현상, 해시 테이블 내에서 데이터가 연속적인 그룹 또는 클러스터를 형성하는 것.  
      -> linear probing 같은 오픈 어드레싱 방법에서 한 번 충돌이 발생하면, 그 근처에 충돌난 데이터를 저장하므로 그 주변의 버킷들도 쉽게 충돌이 발생할 가능성이 높아지는 원인이 됨.
      -> 결과적으로, 한 지점에 데이터가 집중되면서 데이터의 삽입과 검색에 필요한 평균시간 증가.

##### 각 충돌 회피 기법의 장단점
1. **체이닝(Chaining)**
   - 장점 :
      - 삽입, 삭제가 간단, 해시 테이블 크기의 제약이 적음.
      - 해시 테이블의 로드 팩터가 1을 초과해도 잘 동작
      - 해시 테이블의 크기가 충돌의 수에 영향을 덜 받음.
      - 해시 테이블이 가득 차도 성능 저하가 상대적으로 적게 발생
         - 이유 : 해시 버킷 자체가 동적으로 확장 될 수 있음. **충돌의 지역화** : 충돌이 해당 버킷 내부에서만 처리  
            -> 다른 버킷에 영향 미치지 않음.
   - 단점 : 메모리 사용량 늘어날 수 있음, 연결 리스트 탐색하는데 추가 시간 필요, 평균 탐색 시간이 해시 테이블의 로드 팩터에 비례해서 증가
2. **Linear Probing**
   - 장점 : 추가 메모리 사용 없이 해시 테이블 내의 공간을 사용.
   - 단점 : 클러스터링 문제가 발생 가능, 이는 연속된 공간이 점유되어 새로운 요소의 삽입이 어려워짐.
2. **Double Hashing**
   - 장점 : 클러스터링 문제를 상당 부분 해결 가능. 두 번째 해쉬 함수를 사용해 삽입 위치를 다양하게 선택 가능.
   - 단점 : 두 번째 해시 함수를 계산해야 하므로 연산 비용 증가 가능
3. **Quadratic Probing**
   - 장점 : 클러스터링 문제를 linear probing에 비해 감소시킬 수 있음.
   - 단점 : 2차 클러스터링이 발생할 수 있으며, 적절한 탐색 간격 함수의 선택이 중요.

<br>

## 해시 버킷 동적 확장

해시 버킷의 크기가 충분히 크다면 해시 충돌 빈도를 낮출 수 있다

하지만 메모리는 한정된 자원이기 때문에 무작정 큰 공간을 할당해 줄 수 없다

때문에 `load factor`가 일정 수준 이상 이라면 (보편적으로는 0.7 ~ 0.8) 해시 버킷의 크기를 확장하는 동적 확장 방식을 사용한다

- **load factor** : 할당된 키의 개수 / 해시 버킷의 크기
     - 해시 테이블에서 얼마나 밀집하게 저장하고 있는지를 나타내는 지표.
     - 로드 팩터가 낮을 때 : 해시 테이블에 많은 버킷이 비어 있어 충돌 확률이 낮지만, 자원 낭비 가능성
     - 로드 팩터가 높을 때 : 충돌 가능성 높아짐 -> 검색 시간 늘리며 성능 저하 초래 가능. 공간 효율성은 좋음.

로드 팩터는 동적으로 조정될 수 있는데, 해시 버킷이 동적으로 확장 될 때 `리해싱` 과정을 거치게 된다

- **리해싱(Rehashing)** : 버킷의 수를 늘리고 기존 저장되어 있는 모든 값들을 **rehashing**(새로운 버킷에 재배치)하여 새로운 키를 부여하는 것.
   - 잠깐의 성능 저하를 초래할 수 있지만, 장기적으로는 충돌을 줄이고 성능을 개선하는 효과.

<br>

<br>

참고자료 : [링크](https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/)
